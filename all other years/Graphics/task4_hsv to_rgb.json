{"camera":{"position":[3.2865188545314474,3.86810589765737,-4.993111957847802],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"cube","position":[0,0,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\nvarying vec4 colour;\n\n//main program for each vertex\nvoid main() {\n  colour = vec4(vertex_worldSpace, 1.0);\n  colour = 0.5 * (colour + vec4(1.0, 1.0, 1.0, 1.0));\n\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  gl_Position = pMatrix * vertex_camSpace;\n}"},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\nvarying vec4 colour;\n\nuniform float h;\nuniform float s;\nuniform float v;\n\n//main program for each fragment = pixel candidate\nvoid main() {\n  float c = v * s;\n  float x = c * (1. - abs(mod(h / 60., 2.) - 1.));\n  float m = v - c;\n\n  if (0. <= h && h < 60.) {\n    gl_FragColor = vec4(c, x, 0.0, 1.0);\n  } else if (60. <= h && h < 120.) {\n    gl_FragColor = vec4(x, c, 0.0, 1.0);\n  } else if (120. <= h && h < 180.) {\n    gl_FragColor = vec4(0.0, c, x, 1.0);\n  } else if (180. <= h && h < 240.) {\n    gl_FragColor = vec4(0.0, x, c, 1.0);\n  } else if (240. <= h && h < 300.) {\n    gl_FragColor = vec4(x, 0.0, c, 1.0);\n  } else if (300. <= h && h < 360.) {\n    gl_FragColor = vec4(c, 0.0, x, 1.0);\n  }\n\n  gl_FragColor = vec4(gl_FragColor.r + m, gl_FragColor.g + m, gl_FragColor.b + m, 1.0);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"h":{"value":[219]},"s":{"value":[0.5]},"v":{"value":[1]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each fragment of the render quad\nvoid main() {\n  gl_FragColor = texture2D(textureRendered, varyingTextureCoordinate.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}