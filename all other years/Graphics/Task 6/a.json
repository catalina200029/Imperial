{"camera":{"position":[0.0000047651117110765855,-0.000006482132645277395,0.000030623398182637505],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW"},"passes":{"Model":{},"Quad":{"R2T":{"shaders":{"vertex":{"source":"attribute vec4 vertex_worldSpace;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\n\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\n\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nvarying vec3 origin;\nvarying vec3 dir;\n\n//main program for each vertex of the render quad\nvoid main() {\n  float aspectRatio = canvasWidth/canvasHeight;\n  vec3 origin_camSpace, dir_camSpace;\n\n  if (isOrthographicProjection) {\n    origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n                          vertex_worldSpace.y*orthographicFOV,\n                          0);\n\n    dir_camSpace = vec3(0, 0, -1);\n  } else { // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n                        vertex_worldSpace.y,\n                        -1.0/tan(radians(perspectiveFOV)));\n  }\n\n  origin = cameraPosition + cameraRotation*origin_camSpace;\n  dir = normalize(cameraRotation*dir_camSpace);\n  gl_Position = vertex_worldSpace;\n}"},"fragment":{"source":"#define EPSILON 0.00001\n#define PI 3.14\n#define MAX_DEPTH 42\n#define REFLECTIVITY 0.4\n#define NO_OF_SPHERES 6\n\nprecision mediump float;\n\n//model Matrix\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n\nuniform vec4 diffuse;\nuniform vec3 specular;\nuniform float shininess;\n\nuniform vec3 lightPosition;\nvarying vec3 origin;\nvarying vec3 dir;\n\nstruct Ray {\n  vec3 origin;\n  vec3 dir;\n};\n\nstruct Sphere {\n  vec3 centre;\n  float radius;\n  vec3 colour;\n};\n\nstruct Plane {\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n};\n\nstruct Intersection {\n  vec3 point; \n  float mu;\n  bool exists;\n  vec3 normal;\n  vec3 colour;\n};\n\nSphere sphere[NO_OF_SPHERES];\nPlane plane;\n\nIntersection intersect_sphere(Ray ray, Sphere sphere, Intersection intersection) {\n  vec3 change = ray.origin - sphere.centre;\n  float change_dot_dir = dot(change, ray.dir);\n  float discriminant = pow(change_dot_dir, 2.0) - pow(length(change), 2.0) + pow(sphere.radius, 2.0);\n\n  //ray intersects sphere\n  if (discriminant > 0.0) {\n    float mu = max(-change_dot_dir - sqrt(discriminant), 0.0);\n    \n    //intersection is visible\n    if (mu > 0.0) {\n      //get nearest object intersection \n      if (mu < intersection.mu || !intersection.exists) {\n        intersection.mu = mu;\n        intersection.exists = true;\n\n        intersection.point = mu * ray.dir + ray.origin;\n        intersection.normal = normalize(intersection.point - sphere.centre);\n\n        intersection.colour = sphere.colour;\n      }\n    }\n  }\n\n  return intersection;\n}\n\nIntersection intersect_plane(Ray ray, Plane plane, Intersection intersection) {\n  vec3 plane_to_origin = ray.origin - plane.point;\n\n  float mu = -(dot((ray.origin - plane.point), plane.normal)) / dot(ray.dir, plane.normal);\n\n  //check if intersection is visible\n  if (mu > 0.0) {\n    //get closest object intersection \n    if (mu < intersection.mu || !intersection.exists) {\n      intersection.mu = mu;\n      intersection.exists = true;\n      \n      intersection.point = ray.origin + mu * ray.dir;\n      intersection.normal = normalize(plane.normal);\n      \n      //Add checkerboard flooring\n      bool isBlack = mod(floor(intersection.point.x), 2.0) == mod(floor(intersection.point.z), 2.0);\n      if(isBlack){\n          intersection.colour = vec3(0.5, 0.5, 0.5);\n      } else {\n          intersection.colour = plane.colour;\n      }\n    }\n  }\n  return intersection;\n}\n\nIntersection get_nearest_intersection(Ray ray) {\n  Intersection cur_sphere;\n  for (int idx = 0; idx < NO_OF_SPHERES; idx++) {\n    cur_sphere = intersect_sphere(ray, sphere[idx], cur_sphere);\n  }\n\n  Intersection cur_plane;\n  cur_plane = intersect_plane(ray, plane, cur_plane);\n  \n  //check if intersections exist\n  if (!cur_sphere.exists) {\n      return cur_plane;\n  }\n  \n  if (!cur_plane.exists) {\n    return cur_sphere;\n  }\n\n  //get nearest intersection\n  if (cur_sphere.mu < cur_plane.mu) {\n      return cur_sphere;\n  } else {\n      return cur_plane;\n  }\n}\n\nvec3 calculate_shadow(Intersection intersection) {\n  Ray ray;\n  ray.origin = intersection.point + intersection.normal * EPSILON;\n\n  vec3 light_vector = lightPosition - ray.origin;\n  ray.dir = normalize(light_vector);\n\n  Intersection ray_intersection = get_nearest_intersection(ray);\n  \n  if (ray_intersection.exists) {\n    return vec3(0, 0, 0);\n  }\n\n  float distance = length(light_vector);\n  float light_intensity = 1200.0;\n  float atten = light_intensity / (4.0 * PI * distance * distance);\n\n  vec3 intersect_normal = normalize(intersection.normal);\n\n  vec3 diffuse_reflect = intersection.colour * max(dot(intersect_normal, normalize(light_vector)), 0.0);\n  diffuse_reflect = diffuse_reflect * atten;\n\n  //reflected light vector\n  vec3 vector_R = normalize(reflect(light_vector, intersect_normal));\n\n  float specular_angle = max(dot(vector_R, normalize(intersection.point - origin)), 0.0);\n\n  vec3 specular_reflect = specular * pow(specular_angle, shininess) * atten;\n  return  diffuse_reflect + specular_reflect;\n}\n\nvoid initializeScene() {\n  sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n  sphere[0].radius = 1.5;\n  sphere[0].colour = vec3(0.8,0.8,0.8);\n  sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n  sphere[1].radius = 0.6;\n  sphere[1].colour = vec3(0.3,0.8,0.3);\n  sphere[2].centre = vec3(1.0, 0.7, -2.2);\n  sphere[2].radius = 0.8;\n  sphere[2].colour = vec3(0.3,0.8,0.8);\n  sphere[3].centre = vec3(0.7, -0.3, -1.2);\n  sphere[3].radius = 0.2;\n  sphere[3].colour = vec3(0.8,0.8,0.3);\n  sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n  sphere[4].radius = 0.2;\n  sphere[4].colour = vec3(0.8,0.3,0.3);\n  sphere[5].centre = vec3(0.2, -0.2, -1.2);\n  sphere[5].radius = 0.3;\n  sphere[5].colour = vec3(0.8,0.3,0.8);\n\n  plane.point = vec3(0,-0.5, 0);\n  plane.normal = vec3(0, 1.0, 0);\n  plane.colour = vec3(1, 1, 1);\n}\n\n//main program for each fragment of the render quad\nvoid main() {\n  initializeScene();\n  //scene definition end\n\n  vec3 total_colour = vec3(0, 0, 0);\n  float distance;\n  \n  Ray ray;\n  ray.origin = origin;\n  ray.dir = normalize(vec3(mMatrix * vMatrix * vec4(dir, 0)));\n\n  for (int depth = 0; depth < MAX_DEPTH; depth++) {\n    Intersection nearest_intersection = get_nearest_intersection(ray);\n\n    //check if there is an intersection\n    if (nearest_intersection.exists) {\n      total_colour += calculate_shadow(nearest_intersection) * pow(REFLECTIVITY, float(depth));\n    } else { //no intersection exists\n      break;\n    }\n\n    //reflect ray\n    ray.dir = normalize(reflect(ray.dir, nearest_intersection.normal));\n    ray.origin = nearest_intersection.point + nearest_intersection.normal * EPSILON;\n  }\n\n  gl_FragColor = vec4(total_colour, 1.0);\n}"}},"uniforms":{"value":{"canvasWidth":{"value":[560]},"canvasHeight":{"value":[356]},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"value":[false]},"orthographicFOV":{"value":[30]},"perspectiveFOV":{"value":[45]},"mMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"vMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"diffuse":{"value":[0,0,0,0]},"specular":{"value":[1,1,1]},"shininess":{"value":[20]},"lightPosition":{"value":[6,4,3]}}}}}},"output":{"image":"Quad/R2T Pass color"}}