{"camera":{"position":[-0.005634476935448695,-29.76830862808131,0.712008493126277],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWorldCoordinates":true,"showWireframe":false},"passes":{"Model":{},"Quad":{"R2T":{"shaders":{"vertex":{"source":"attribute vec4 vertex_worldSpace;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nvarying vec3 origin;\nvarying vec3 dir;\n\nvoid main() {\n    float aspectRatio = canvasWidth/canvasHeight;\n    vec3 origin_camSpace, dir_camSpace;\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n        vertex_worldSpace.y*orthographicFOV,\n        0);\n        dir_camSpace = vec3(0, 0, -1);\n    }\n    else { // perspective projection\n        origin_camSpace = vec3(0);\n        dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n        vertex_worldSpace.y,\n        -1.0/tan(radians(perspectiveFOV)));\n    }\n    origin = cameraPosition + cameraRotation*origin_camSpace;\n    dir = normalize(cameraRotation*dir_camSpace);\n\n    gl_Position = vertex_worldSpace;\n}"},"fragment":{"source":"#define MAX_DEPTH 42\n#define EPSILON 0.000001\n#define PI 3.1415926538\n#define NUM_SPHERES 6\n\nprecision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//uniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\n\n//ray components calculated from vertex shader\nvarying vec3 origin;\nvarying vec3 dir;\n\n//spec has the value (6, 4, 3)\nuniform vec3 light_source;\n\nuniform float Ka; //coefficient for ambient\nuniform float Kd; //coefficient for diffuse\nuniform float Ks; //coefficient for specular\n\nuniform float shininess; //specular exponent - set to 10.0 like in task 3\n\n//shapes as defined by the specification\nstruct Sphere\n{\n  vec3 centre;\n  float radius;\n  vec3 colour;\n};\n\nstruct Plane\n{\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n};\n\n//my definition of a ray\nstruct Ray {\n  vec3 origin;\n  vec3 dir;\n};\n\n//my definition of a intersection\nstruct Intersection{\n\tfloat t; //reprsents the distance along the ray vector\n    vec3 point; //point of intersection\n    vec3 normal;\n\tbool hit; //flag to detect whether there was a intersection with an object in our world\n\tvec3  colour; //colour at intersection point\n};\n\nvoid intersect_sphere(Sphere sphere, Ray ray, inout Intersection i) {\n  vec3 dp = ray.origin - sphere.centre;\n\n  float b = dot(ray.dir, dp);  // (d . dp)\n  float c = pow(length(dp), 2.0) - pow(sphere.radius, 2.0);  // |dp|^2 - r^2\n  float discriminant = pow(b, 2.0) - c;\n\n  if (discriminant > 0.0) {\n\n    float mew = max(-b - sqrt(discriminant), 0.0);  // ray entry\n\n    if (mew > 0.0 && (mew < i.t || !i.hit)) {\n      i.hit = true;\n      i.t = mew;\n\n      i.point = ray.origin + (mew * ray.dir);\n      i.normal = normalize(i.point - sphere.centre);\n      i.colour = sphere.colour;\n    }\n  }\n}\n\n\nvoid intersect_plane(Plane plane, Ray ray, inout Intersection i) {\n    float a = dot(ray.origin - plane.point, plane.normal);  // (p0 - p1) . n\n    float b = dot(ray.dir, plane.normal);  // (d . n)\n\n    // No intersection\n    if (b == 0.0) { return; }\n    \n    float mew = - (a / b);\n    if (mew > 0.0 && (mew < i.t || !i.hit)) {\n        i.hit = true;\n        i.t = mew;\n\n        i.point = ray.origin + (mew * ray.dir);\n        i.normal = plane.normal;\n\n        bool isComp = mod(floor(i.point.x), 2.0) == mod(floor(i.point.z), 2.0);\n        i.colour = isComp ? \n            vec3(1.0 - plane.colour.x, 1.0 - plane.colour.y, 1.0 - plane.colour.z) : plane.colour;\n    }\n}\n\nSphere sphere[NUM_SPHERES];\nPlane plane;\nvoid intersect(Ray ray, inout Intersection i) {\n    i.hit = false;\n    intersect_plane(plane, ray, i);\n    for (int s_i = 0; s_i < NUM_SPHERES; s_i++) {\n        intersect_sphere(sphere[s_i], ray, i);\n    }\n}\n\nvec3 compute_shadow(in Intersection i, vec3 viewdir)\n{\n  Intersection shadow_i;\n  shadow_i.hit = false;\n  Ray to_light;\n  to_light.origin = i.point + EPSILON * i.normal;\n  to_light.dir = normalize(light_source - to_light.origin);\n  intersect(to_light, shadow_i);\n  \n  if(shadow_i.hit)\n  {\n    //shadow - black\n    return vec3(0.0,0.0,0.0);\n  } else {\n    //not shadow\n    float light_intensity = 1200.0;\n    float d = distance(light_source, to_light.origin);\n\n    //light gets weaker due to inverse square law of distance\n    float attenuation = light_intensity / (4.0 * PI * d * d);\n    \n    vec3 diffuseColour = i.colour;\n    vec3 diffuse = Kd * attenuation * diffuseColour * dot(i.normal, to_light.dir);\n\n    vec3 specularColour = i.colour;\n    vec3 r = reflect(to_light.dir, i.normal);\n    vec3 e = normalize(viewdir);\n    vec3 specular = Ks * attenuation * specularColour * pow(max(dot(r, e), 0.0), shininess);\n\n    //illumination equation = ambience + diffuse + specular\n    vec3 output_colour = (Ka * i.colour) + diffuse + specular;\n\n    return output_colour;\n  }\n}\n\nvoid scene_init() {\n    //scene definition begin\n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n    plane.point = vec3(0.0,-0.5, 0);\n    plane.normal = vec3(0.0, 1.0, 0);\n    plane.colour = vec3(1.0, 1.0, 1.0);\n    //scene definition end\n}\n\nvoid ray_init(inout Ray ray) {\n    //ray initialistation\n    mat4 modelViewMatrix = modelMatrix * viewMatrix;\n    ray.origin = normalize((modelViewMatrix * vec4(origin, 0)).xyz);\n    ray.dir = normalize((modelViewMatrix * vec4(dir, 0)).xyz);\n}\n\n//main program for each fragment of the render quad\nvoid main() {\n    Ray ray;\n    ray_init(ray);\n\n    scene_init();\n    vec3 total_colour = vec3(0.0,0.0,0.0);\n    Intersection i;\n    \n    float reflectivity = 0.5;\n    for (int depth = 1; depth <= MAX_DEPTH; depth++) {\n        intersect(ray, i);\n        if (i.hit) {\n            vec3 colour = compute_shadow(i, ray.dir);\n            total_colour += colour * pow(reflectivity, float(depth));\n\n            ray.origin = i.point + EPSILON * i.normal;\n            ray.dir = reflect(ray.dir, i.normal);\n        } else {\n            break;\n        }\n    }\n\n    gl_FragColor = vec4(total_colour, 1.0);\n}"}},"uniforms":{"value":{"canvasWidth":{"value":[60]},"canvasHeight":{"value":[50]},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"value":[false]},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"textureRendered":{"value":{"TEXTURE_2D":""}},"modelMatrix":{"value":[1,0,0,0,0,6.123233995736766e-17,-1,0,0,1,6.123233995736766e-17,0,0,-8,0,1]},"viewMatrix":{"value":[1,0,0,0,1.3877787807814454e-17,1,0,0,0,0,1,0,0,0,0,1]},"light_source":{"value":[6,4,3]},"Ka":{"value":[0.3]},"Kd":{"value":[1]},"Ks":{"value":[1]},"shininess":{"value":[10]}}}}}},"output":{"image":"Quad/R2T Pass color"}}