{"camera":{"position":[-2.544796916672109,-7.07152779152656,69.29031040331559],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWorldCoordinates":true,"showWireframe":false},"passes":{"Quad":{"R2T":{"shaders":{"vertex":{"source":"uniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\n//vertex coordinates in world space for the render quad\nattribute vec4 vertex_worldSpace;\n\nvarying vec3 origin;\nvarying vec3 dir;\n\nvoid main() {\n  float aspectRatio = canvasWidth/canvasHeight;\n  vec3 origin_camSpace, dir_camSpace;\n\n  if (isOrthographicProjection) {\n    origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n                           vertex_worldSpace.y*orthographicFOV,\n                           0);\n    dir_camSpace = vec3(0, 0, -1);\n  }\n  else { // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n                      vertex_worldSpace.y,\n                      -1.0/tan(radians(perspectiveFOV)));\n  }\n\n  origin = cameraPosition + cameraRotation*origin_camSpace;\n  dir = normalize(cameraRotation*dir_camSpace);\n  gl_Position = vertex_worldSpace;\n}"},"fragment":{"source":"#define PI 3.1415926535897932384626433832795\n#define MAX_DEPTH 42\n#define EPSILON 0.00001\n#define NUM_SPHERES 6\n#define REFLECTIVITY 0.5\n\nprecision mediump float;\n\nconst int depth = 42;\n\nuniform vec4 k_ambient;\nuniform vec4 k_diffuse;\nuniform vec4 k_specular;\nuniform float shininess;\n\n//uniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\n\nuniform vec3 light_pos;\nuniform float phi_s;\n\nvarying vec3 origin;\nvarying vec3 dir;\n\nstruct Sphere {\n  vec3 centre;\n  float radius;\n  vec3 colour;\n};\n\nstruct Plane {\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n};\n\nstruct Ray {\n  vec3 origin; // where the ray starts\n  vec3 dir; // the direction of the ray\n};\n\nstruct Intersection {\n  float d; // distance along the ray vector\n  bool hitObject; // if the ray hit an object\n  vec3 point; // where the ray hit the object\n  vec3 normal;\n  vec3 colour; // the colour at the intersection point\n};\n\nSphere spheres[NUM_SPHERES];\nPlane plane;\nRay ray;\n\nvoid initialiseScene() {\n  spheres[0].centre = vec3(-2.0, 1.5, -3.5);\n  spheres[0].radius = 1.5;\n  spheres[0].colour = vec3(0.8,0.8,0.8);\n  spheres[1].centre = vec3(-0.5, 0.0, -2.0);\n  spheres[1].radius = 0.6;\n  spheres[1].colour = vec3(0.3,0.8,0.3);\n  spheres[2].centre = vec3(1.0, 0.7, -2.2);\n  spheres[2].radius = 0.8;\n  spheres[2].colour = vec3(0.3,0.8,0.8);\n  spheres[3].centre = vec3(0.7, -0.3, -1.2);\n  spheres[3].radius = 0.2;\n  spheres[3].colour = vec3(0.8,0.8,0.3);\n  spheres[4].centre = vec3(-0.7, -0.3, -1.2);\n  spheres[4].radius = 0.2;\n  spheres[4].colour = vec3(0.8,0.3,0.3);\n  spheres[5].centre = vec3(0.2, -0.2, -1.2);\n  spheres[5].radius = 0.3;\n  spheres[5].colour = vec3(0.8,0.3,0.8);\n\n  plane.point = vec3(0,-0.5, 0);\n  plane.normal = vec3(0, 1.0, 0);\n  plane.colour = vec3(1, 1, 1);\n}\n\nvoid initRay(inout Ray ray) {\n  ray.origin = normalize((modelMatrix * viewMatrix * vec4(origin, 0)).xyz);\n  ray.dir = normalize((modelMatrix * viewMatrix * vec4(dir, 0)).xyz);\n}\n\nvec3 getPlaneBlockColour(Intersection intersection) {\n  bool isBlackBlock = mod(floor(intersection.point.x), 2.) == mod(floor(intersection.point.z), 2.);\n  return isBlackBlock ? (plane.colour / 2.) : plane.colour;\n}\n\n// intersection will be updated to represent the intersection between the plane and the ray\nvoid intersect_plane(Plane plane, Ray ray, inout Intersection intersection) {\n  float a = dot(ray.origin - plane.point, plane.normal);\n  float b = dot(ray.dir, plane.normal);\n\n  // If there could be an intersection, i.e. the ray is not perpendicular on the ray\n  if (b != 0.) {\n    // d is defined such that ray.origin + ray.direction * d = intersection.point\n    float d = - (a / b);\n\n    // Need to check if the ray hits the plane and if this intersection point is closer than the previously determined intersection \n    if (d > 0. && (d < intersection.d || !intersection.hitObject)) {\n      intersection.hitObject = true;\n      intersection.d = d;\n\n      intersection.point = ray.origin + d * ray.dir;\n      intersection.normal = plane.normal;\n\n      intersection.colour = getPlaneBlockColour(intersection);\n    }\n  }\n}\n\n// intersection will be updated to represent the intersection between the sphere and the ray\nvoid intersect_sphere(Sphere sphere, Ray ray, inout Intersection intersection) {\n  vec3 centre_to_ray = ray.origin - sphere.centre;\n\n  float b = dot(ray.dir, centre_to_ray);\n  float c = length(centre_to_ray) * length(centre_to_ray) - sphere.radius * sphere.radius;\n  float discriminant = b * b - c;\n\n  // If the equation has a solution\n  if (discriminant > 0.) {\n    float d = max(- b - sqrt(discriminant), 0.);\n\n    // Need to check if the ray hits the sphere and if this intersection point is closer than the previously determined intersection \n    if (d > 0. && (d < intersection.d || !intersection.hitObject)) {\n      intersection.hitObject = true;\n      intersection.d = d;\n\n      intersection.point = ray.origin + (d * ray.dir);\n      intersection.normal = normalize(intersection.point - sphere.centre);\n\n      intersection.colour = sphere.colour;\n    }\n  }\n}\n\n// intersection will be the closest point that the ray hits, either on a plane or on a sphere\nvoid intersect(Ray ray, inout Intersection intersection) {\n  intersection.hitObject = false;\n\n  intersect_plane(plane, ray, intersection);\n\n  for (int i = 0; i < NUM_SPHERES; i++) {\n    intersect_sphere(spheres[i], ray, intersection);\n  }\n}\n\nvec3 phong(Intersection intersection, vec3 viewDir) {\n  Intersection otherIntersection;\n  otherIntersection.hitObject = false;\n\n  Ray toLight;\n  toLight.origin = intersection.point + EPSILON * intersection.normal;\n  toLight.dir = normalize(light_pos - toLight.origin);\n\n  intersect(toLight, otherIntersection);\n\n  // If there is an object between the light and our intersection point\n  if(otherIntersection.hitObject)\n    // the shadow is black\n    return vec3(0., 0., 0.);\n  else {\n    // Otherwise compute the phong illumination colour\n\n    vec3 N = intersection.normal;\n    vec3 L = normalize(toLight.dir);\n    vec3 V = normalize(viewDir);\n\n    float N_times_L = max(dot(N, L), 0.0);\n\n    vec3 R = reflect(L, N);\n\n    float V_TIMES_R = max(dot(V, R), 0.0);\n\n    float D = distance(light_pos, toLight.origin);\n\n    float diffuse = N_times_L;\n\n    float specular = pow(V_TIMES_R, shininess);\n\n    return vec3(k_ambient + (k_diffuse * diffuse + k_specular * specular) * phi_s / (4. * PI * D * D)) * intersection.colour;\n  }\n}\n\nvoid main() {\n  // Initialise\n  initialiseScene();\n  initRay(ray);\n\n  Intersection intersection;\n  vec3 finalColour = vec3(0., 0., 0.);\n\n  // Reflect the ray MAX_DEPTH times\n  for (int currentDepth = 1; currentDepth <= MAX_DEPTH; ++currentDepth) {\n    intersect(ray, intersection);\n\n    if (!intersection.hitObject) break;\n\n    vec3 intersectionColour = phong(intersection, ray.dir);\n    finalColour += intersectionColour * pow(REFLECTIVITY, float(currentDepth));\n\n    ray.origin = intersection.point + EPSILON * intersection.normal;\n    ray.dir = reflect(ray.dir, intersection.normal);\n  }\n\n  gl_FragColor = vec4(finalColour, 1.);\n}"}},"uniforms":{"value":{"canvasWidth":{"value":[60]},"canvasHeight":{"value":[50]},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"value":[false]},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"k_ambient":{"value":[0.5,0.5,0.5,1]},"k_diffuse":{"value":[1,1,1,1]},"k_specular":{"value":[1,1,1,1]},"shininess":{"value":[10]},"modelMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"viewMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,-3.0508974887195864e-15,0,0,1]},"light_pos":{"value":[6,4,3]},"phi_s":{"value":[1200]}}}}}},"output":{"image":"Quad/R2T Pass color"}}